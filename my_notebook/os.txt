https://python-scripts.com/import-os-example

os.name		#nt	Это говорит нам о том, что наш экземпляр Пайтон работает в окне Windows.
			Как мы об этом узнали? Майкрософт начали называть свою операционную систему NT много лет назад. 
			Например, Windows 7 также носит имя Windows NT 6.1.


os.environ	# 		Значение os.environ известно как объект мэппинга (сопоставления), который работает со словарем переменных пользовательской среды.
				Возможно вы не знали, но каждый раз, когда вы пользуетесь своим компьютером, некоторые переменные среды уже установлены.
				Это дает вам полезную информацию, такую как количество процессоров, тип ОЗУ, имя компьютера, и так далее. 
				Посмотрим, что мы сможем узнать о нашем компьютере: '.......'

				print(os.environ["TMP"]) # C:\\Users\\mike\\AppData\\Local\\Temp
				



os.chdir()			Функция os.chdir позволяет нам вносить изменения в каталоге, который мы в данный момент используем в сессии.

os.getcwd()			Если вам нужно знать, какой путь вы в данный момент используете, для этой нужно вызвать os.getcwd()

os.getenv()	#		print(os.getenv("TMP")) # C:\\Users\\mike\\AppData\\Local\\Temp 
				Полезность использования os.getenv() вместо словаря os.environ заключается в том, что если вы находитесь в положении, 
				когда вам нужно получить доступ к переменной среды, которая не существует, функция getenv попросту ничего не сделает.
				Если вы попытаетесь сделать то же самое, пользуясь os.environ, вы получите уведомление об ошибке.

os.putenv()

os.mkdir()			 os.mkdir(), позволяет создать одну папку

os.makedirs()			Функция os.makedirs() создает промежуточные папки в пути, если их там нет. В целом, это значит, что вы создали путь, в котором размещены папки.
				Лично я часто прибегал к данному решению, когда была необходимость создания журнала, с датированной структурой, например Год\Месяц\День.
					# path = r'C:\Users\mike\Documents\pytest\2014\02\19'
					# os.makedirs(path)

os.remove()			Функции os.remove() используются для удаления файлов 		

os.rmdir()			Функции os.rmdir() используются для удалениякаталогов

os.rename()			os.rename(src, dst)
				Функция os.rename() применяется тогда, когда нужно переименовать файл или папку.
					# os.rename("test.txt", "pytest.txt")

os.startfile()			Метод os.startfile() позволяет нам «запустить» файл в привязанной к нему программе. Другими словами, 
				мы можем открыть файл вместе с привязанной к нему программой, как когда вы открываете файл PDF двойным щелчком, и он открывается в программе Adobe Reader
					# os.startfile(r'C:\Users\mike\Documents\labels.pdf')

os.walk()			Метод os.walk() дает нам возможность для итерации на корневом уровне пути. 
				Это значит, что мы можем назначить путь к этой функции и получить доступ ко всем её подкаталогам и файлам.
 				Используем одну из папок Пайтон, при помощи которой мы можем проверить данную функцию.
					# path = r'C:\Python27\Tools'
 
					for root, dirs, files in os.walk(path):
    						print(root)



os.path				Подмодуль os.path модуля os имеет широкий ряд встроенных преимуществ. Ознакомимся со следующими функциями:

		#basename   		Это очень полезная функция, особенно в тех случаях, когда нужно использовать имя файла для наименования того или иного связанного с работой файла, например лог-файл.
										 Такая ситуация возникает часто при работе с файлами данных.
						os.path.basename(r'C:\Python27\Tools\pynche\ChipViewer.py')

		#dirname			print( os.path.dirname(r'C:\Python27\Tools\pynche\ChipViewer.py') )

					В данном примере мы просто возвращаем путь к каталогу. Это также полезно, когда вам нужно сохранить другие файлы рядом с тем, 
					который вы обрабатываете в данный момент. Как и в случае с лог-файлом, упомянутым выше.


		#exists			Функция exists говорит нам, существует ли файл, или нет. Все что вам нужно, это указать ему путь.

						os.path.exists(r'C:\Python27\Tools\pynche\ChipViewer.py') # True
 
						os.path.exists(r'C:\Python27\Tools\pynche\fake.py') # False


		#isdir and isfile	Методы isdir и isfile тесно связаны с методом exists, так как они также тестируют присутствие или отсутствие файлов или папок на тех или иных путях.
					 Однако, isdir проверяет только пути к папкам, а isfile, соответственно, к файлам.
					 Если вам нужно проверить путь, и не важно, папка это или файл, проще будет воспользоваться методом exists
							os.path.isfile(r'C:\Python27\Tools\pynche\ChipViewer.py') # True
 
							os.path.isdir(r'C:\Python27\Tools\pynche\ChipViewer.py') # False
 
							os.path.isdir(r'C:\Python27\Tools\pynche') # True
 
							os.path.isfile(r'C:\Python27\Tools\pynche') # False


		#join			Метод join позволяет вам совместить несколько путей при помощи присвоенного разделителя. К примеру, в Windows, в роли разделителя выступает бэкслэш (косая черта, указывающая назад),
					 однако в Linux функция разделителя присвоена косой черте, указывающей вперед (forward slash).	

							print( os.path.join(r'C:\Python27\Tools\pynche', 'ChipViewer.py') )
							# C:\\Python27\\Tools\\pynche\\ChipViewer.py	
					В данном примере мы совместили путь каталога и файла вместе, для получения рабочего пути. Обратите внимание на то, что метод join не указывает на то, какой результат в итоге вышел.


		#split	Метод split разъединяет путь на кортеж, который содержит и файл и каталог. Взглянем на пример:
	
				print( os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py') )
				# ('C:\\Python27\\Tools\\pynche', 'ChipViewer.py')

				print( os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py') )
				# ('C:\\Python27\\Tools\\pynche', 'ChipViewer.py')
			В данном примере показано, что происходит, когда мы указываем путь к файлу. Теперь взглянем на то, что происходит, если в конце пути нет названия файла:

				print( os.path.split(r'C:\Python27\Tools\pynche') )
				# (‘C:\Python27\Tools’, ‘pynche’)

				print( os.path.split(r'C:\Python27\Tools\pynche') )
				# (‘C:\Python27\Tools’, ‘pynche’)
			Как видите, данная функция берет путь и разъединяет его таким образом, что подпапка стала вторым элементом кортежа с остальной частью пути в первом элементе. Напоследок, взглянем на бытовой случай использования split:

				dirname, fname = os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py')
				print(dirname)
				# C:\\Python27\\Tools\\pynche

				dirname, fname = os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py')
				print(dirname)
				# C:\\Python27\\Tools\\pynche
 
				print(fname)
				# ChipViewer.py
			В данном примере указано, как сделать множественное назначение. Когда вы разъединяете путь, он становится кортежем, состоящим из двух частей. 
			После того, как мы опробовали две переменные с левой части, первый элемент кортежа назначен к первой переменной, а второй элемент к второй переменной соответственно.













	






